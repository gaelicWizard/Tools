#!/bin/sh

## This script is designed to be used like a command to encrypt/decrypt files.
## It uses RC-4 (128-bit) encryption technology, which is the same as what most
## secure web sites use. Encrypted files have the .crypt suffix appended to the
## file name.
##
## Crypt is free and very powerful. It uses open source (OpenSSL) technology and
## can be used to encrypt/decrypt as many files as you want in a single command.
##
## Use at your own risk.
##
## Copyright 2003, Bruno Courbage
## All rights reserved.
##
## btc@monaco.net
##
## Version 1.0
## 28 February 2003

## Version 1.1
## 6 March 2003
## Changelog:
##  Adds a shred option (-s) to secure delete files instead of just the standard remove command. 
##   The shred will overwrite the file 25 times then add a final overwrite with zeros to hide the shredding.
##   Finally it removes the file after shredding. The remove (-r) option is still available.

## Cleaned up by johnpell@mac.com
## Changes are public domain.
##
## Version 1.0.1 (accidentally released as a false "1.1")
## 22 May 2004
##
## Changelog:
##  All messages generated by the script now go to stderr.
##  Files are NOT deleted if the encryption/decryption fails, even if -r (or -s) specified
##  Password is read from stdin. (What were you thinking?)
##  Changed error message for "both -e and -d".
##  In manual encryption mode, encrypt EVEN IF ALREADY encrypted
##    (since the user did specify FORCE on the command line).
##  Added quotes around $# for usage statement
##    (only because it screwed up my happy syntax highlighting).
##  Changed all instances of "[ ! -s" to "[ ! -r",
##    if the user wants to encrypt an empty file, that's their perogative.
##  Removed all TAB characters (replaced with 4 spaces).

## More work by johnpell@mac.com
## Changes are still public domain.
##
## Version 1.1.0.999 (will become 1.1.1?)
## 22 May 2004
##
## Changelog:
##  Fixed a bug I created in in the manual decrypt mode,
##    I left out an entire else section!
##  Clarified previous changelog.
##  Changed error message for "both -e and -d", again.
##  Changed automatic mode to NOT depend on file extension.
##  Clarified usage statement.
##  Added some quotes to ensure space-in-file-name friendlyness.
##  Added checks for failed encryption/decryption to manual mode.
##  Started adding additional comments to the code.
##  This script is now hosted on my site at http://projects.gaelicWizard.net/crypt.sh.txt .
##  Since passwords are read per-file, tell the user so in the password prompt.
##  Encrypted files are now left in the CURRENT directory.
##  Merged in 1.1 release, which I had not known was released by the original author. :-)
##  I don't know what -u does to shred, and I only have srm, so I have removed the -u option (srm doesn't have it).
##    srm defaults to 7 DoD compliant passes, so I'll leave it at that. :-)
##  Since I didn't know about the 1.1 version, I had previously named my update as 1.1,
##    it is now labelled as 1.0.1.
##  Changed error message for '-r and -s' options.

## Even more work by johnpell@mac.com
## Changes are still public domain.
##
## Version 1.1.1.999 (will become 1.2?)
## 12 July 2004
##
## Changelog:
##  Reimplimented most of the script to use local functions (primarily to reduce code duplication)
##    The DELTOPTS env var is the arg to be submitted to the doCrypt/doDecrypt functions, which handle the actual rm/shred
##    No function uses any variables that are defined and/or used outside of it, to allow for possible future expansion
##    return values: 
##      0 means success, duh 
##      1 means user-correctible failure (usually accompanied by an error message)
##      2 means script-error (usually incorrect number of arguments)
##  Fixed typo ("OpenSSH" to "OpenSSL") in introduction. I'm not sure if I did it or if the origional author did.
##
## I am unsure, but I think that at this point the similarities to the origional work are negligable. 
## Common Sense would dictate that this is now primarily, or entirely, my work, and so I can release it as I see fit.
## Its public domain, if I'm right. :-) The more GNU-like alternative would be that since I still have characters 
##  in this file that were origionally typed by the origional author, then he still retains copyright of that portion,
##  rights to which he has reserved (see copyright notice above). No matter, if I cared I could simply delete those 
##  five lines and type replacements, which might be rediculously similar...

## Came back to it again, johnpell@mac.com
## ...mumble... public domain ...mumble...
##
## Version 1.2.999 (Will become 1.3)
## 28 Dec 2004
##
## Changelog:
##  Removed back-slashes before the newlines in the Usage statement, and quoted all instances of "$USAGE"
##   (it now actually prints on multiple lines!)
##  Added code to guess location of shred or srm
##  Added quotes to `basename "$FILE"` to maintain space-in-file-name-friendlyness

## More changes by johnpell@mac.com
## As before, all my changes are public domain.
##
## Version 1.3.999
## 22 Nov 2006 (its been a while!)
##
## Changelog:
##  Fixed typo in my paragraph on the license for this file above.
##  Changed "$CMDNAME" to "$SELF", cuz I like $SELF better.
## ??

## TODO:
##  Increase encryption.
##  Add option to choose encryption method.
##  *DONE* Reduce code duplication between manual and automatic modes, functions sound like a good way to go...
##  Change options to encrypt and/or decrypt files in manual mode from the same invocation,
##    You should be able to specify certain files to encrypt or decrypt.
##  Add code to handle directories. Either by tar'ing or by recursive, individual encryption.
##  *DONE* Fix usage statement to NOT be all on one line.
##  Add command line options for srm/shred flags.
##  *DONE* Test more to make sure that old files are NOT deleted when encryption/decryption fails.
##  Every file name is repeated several times ("Encrypting/Decrypting $FILE" and "Password for $FILE"), clean it up
##  *DONE* Make sure that spaces in file names do not become newlines in new filename...?
##  *DONE* Guess location of shred/srm

## Begin:

# Print all messages to stderr
exec 1>&2

# Initialize all local variables
ENCRYPT=FALSE
DECRYPT=FALSE
DELTOPTS=""
FAILED=FALSE

SHRED=`type -p shred || type -p srm`

SDELTOPTS='-z ' # add -u for shred.

SELF="`basename $0`"
USAGE="Usage: $SELF [-d | -e] [-r | -s] file(s) 
    -d        Force decryption 
    -e        Force encryption 
    -r        Delete original file (overrides -s) 
    -s        Shred (secure delete) original file (overrides -r)"

# Parsing command line
if [ "$#" -lt 1 ]
then # no arguments!
    echo "$USAGE"
    exit 1
fi

# Process command line options
while getopts edrs OPT
do
  case $OPT in
      e)  
	  ENCRYPT=TRUE        # forces encryption
	  ;;
      d)  
	  DECRYPT=TRUE        # forces decryption
	  ;;
      r)  
	  DELTOPTS="-r $DELTOPTS"       # delete original file
	  ;;
      s)  
	  DELTOPTS="-s $DELTOPTS"       # delete original file, securely
	  ;;
      '?')
	  echo "$USAGE"
	  exit 1
	  ;;
  esac
done
shift `expr $OPTIND - 1`
unset OPT OPTIND

# Check for sane invocation
if [ $ENCRYPT = TRUE -a $DECRYPT = TRUE ]
then # Can't encrypt *and* decrypt at the same time! (yet!)
    echo "Error: -e and -d are mutually exclusive."
    exit 1
fi

#functions for (de)crypting
function isCrypt {
    # Determine whether or not a file is encrypted
    if [ -e "$1" ]
    then # file exists
	if [ `head -n 1 "$1" | grep -c "Salted__"` -ge 1 ]
	then # and is encrypted
	    return 0
	else # but is not encrypted
	    return 1
	fi
    else # file does not exist
	return 2
    fi
}

function encrypt {
    if [ "$1" != "" -a "$2" == "" ]
    then # One argument, encrypt it!
	FILE="$1"

        if [ -d "$FILE" ] || [ ! -r "$FILE" ]
	then # File is a directory or is unreadible, fail
	    return 1
        fi
        
        OUTFILE="`basename "$FILE"`.crypt"
        echo -n "Encryption Passphrase for $FILE: "
        openssl enc -rc4 -in "$FILE" -out "$OUTFILE" -e -pass stdin || return 1
    else # Wrong number of arguments
	return 2
    fi
}

function decrypt {
    if [ "$1" != "" -a "$2" == "" ]
    then # One argument, drcrypt it!
	FILE="$1"

	if [ -d "$FILE" ] || [ ! -r "$FILE" ]
	then # File is a directory or is unreadible, fail
            return 1
        fi

	OUTFILE="`basename "$FILE" | sed -e 's/.crypt\$//'`"
	echo -n "Decryption Passphrase for $FILE: "
	openssl enc -rc4 -in "$FILE" -out "$OUTFILE" -d -pass stdin || return 1
    else # Wrong number of arguments
	return 2
    fi
}

function doCrypt {
    # parse the function's args to determine whether or not to delete origional file, and how
    while getopts rs OPT
      do
      case $OPT in
	  r)      DELT=TRUE           # delete original file
	      ;;
	  s)      SDELT=TRUE          # delete original file
	      ;;
      esac
    done
    shift `expr $OPTIND - 1`
    unset OPT OPTIND

    if [ "$1" != "" -a "$2" == "" ] 
    then # One argument, encrypt it!
	FILE="$1"

	echo "Encrypting $FILE..."
	
	if [ -d "$FILE" ];then
	    echo "Error: $FILE is a directory. Unable to encrypt a directory."
	    return 1
	fi
	
	if [ ! -r "$FILE" ];then
	    echo "Error: $FILE is not readable. Unable to encrypt unreadable files."
	    return 1
	fi
	
	encrypt "$FILE" || return $?
	
	if [ "$SDELT" == TRUE ];then
	    $SHRED $SDELTOPTS "$FILE" &
	elif [ "$DELT" == TRUE ];then
	    rm -f "$FILE" &
	fi
	
	return 0
    else # no args, or to many args
        echo "Error: $FUNCNAME can take only one argument."
	return 2
    fi
}

function doDecrypt {
    # parse the function's args to determine whether or not to delete origional file, and how
    while getopts rs OPT
      do
      case $OPT in
          r)      DELT=TRUE           # delete original file
              ;;
          s)      SDELT=TRUE          # delete original file
              ;;
      esac
    done
    shift `expr $OPTIND - 1`
    unset OPT OPTIND

    if [ "$1" != "" -a "$2" == "" ] # one argument only, $FILE
    then
        FILE="$1"

        if [ -d "$FILE" ];then
            echo "Error: $FILE is a directory. Unable to decrypt a directory."
            return 1
        fi

        if [ ! -r "$FILE" ];then
            echo "Error: $FILE is not readable. Unable to decrypt unreadable files."
            return 1
        fi

        if isCrypt "$FILE";then
            echo "Decrypting $FILE..."

	    decrypt "$FILE" || return $?

	    if [ "$SDELT" == TRUE ];then
		$SHRED $SDELTOPTS "$FILE" &
	    elif [ "$DELT" == TRUE ];then
		rm -f "$FILE"
	    fi
        else
            echo "Error: $FILE is not encrypted: Unable to decrypt unencrypted files."
            return 1
        fi
    else # Wrong number of arguments
        echo "Error: $FUNCNAME can take only one argument."
	return 2
    fi
}	

# Use all other parameters as files to encrypt/decrypt.
if [ $ENCRYPT = TRUE ]
then # Manual encription mode
    for FILE in "$@"
    do
      doCrypt $DELTOPTS "$FILE"
    done
elif [ $DECRYPT = TRUE ]
then # Manual decryption mode
    for FILE in "$@"
    do
      doDecrypt $DELTOPTS "$FILE"
    done
else # Automatic mode
    for FILE in "$@"
    do
        if echo "$FILE" | grep -c '.crypt' >/dev/null 2>&1 || isCrypt "$FILE"
        then
	    doDecrypt $DELTOPTS "$FILE"
        else
	    doCrypt $DELTOPTS "$FILE"
        fi
    done
fi

exit 0

## End.
